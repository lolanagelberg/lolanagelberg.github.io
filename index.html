<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Probe Controller</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            padding: 20px;
            max-width: 800px;
            margin: 0 auto;
            background-color: #f0f0f0;
        }
        
        h1, h2 {
            text-align: center;
        }
        
        .container {
            background-color: #fff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        .api-info {
            background-color: #e9f7fe;
            color: #0c5460;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
            margin-bottom: 20px;
            font-weight: bold;
        }
        
        .position-display {
            display: none;
            justify-content: space-around;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .position-card {
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            width: 30%;
            margin-bottom: 10px;
        }
        
        .position-card h3 {
            margin-top: 0;
            font-size: 16px;
        }
        
        .position-value {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
            margin: 10px 0;
        }
        
        .button-panel {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-gap: 10px;
            margin: 20px 0;
        }
        
        .button-panel button {
            padding: 20px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            transition: all 0.2s ease;
        }
        
        .button-panel button:hover {
            background-color: #45a049;
            transform: scale(1.05);
        }
        
        .button-panel button:active {
            background-color: #ff4757;
            transform: scale(0.98);
        }
        
        #up {
            grid-column: 2;
            grid-row: 1;
        }
        
        #left {
            grid-column: 1;
            grid-row: 2;
        }
        
        #center {
            grid-column: 2;
            grid-row: 2;
            background-color: #6c757d;
        }
        
        #right {
            grid-column: 3;
            grid-row: 2;
        }
        
        #down {
            grid-column: 2;
            grid-row: 3;
        }
        
        #forward, #backward {
            padding: 15px;
            font-size: 18px;
            font-weight: bold;
            background-color: #2196F3;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 10px;
            flex: 1;
            transition: all 0.2s ease;
        }
        
        #forward:hover, #backward:hover {
            background-color: #0b7dda;
            transform: scale(1.05);
        }
        
        #forward:active, #backward:active {
            background-color: #ff4757;
            transform: scale(0.98);
        }
        
        .z-buttons {
            display: flex;
            justify-content: center;
        }
        
        .rotation-controls {
            margin: 20px 0;
        }
        
        .rotation-panel {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-gap: 10px;
        }
        
        .rotation-panel button {
            padding: 12px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            background-color: #9c27b0;
            color: white;
            border: none;
            border-radius: 5px;
            transition: all 0.2s ease;
        }
        
        .rotation-panel button:hover {
            background-color: #7b1fa2;
            transform: scale(1.05);
        }
        
        .rotation-panel button:active {
            background-color: #ff4757;
            transform: scale(0.98);
        }
        
        .increment-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
            justify-content: center;
        }
        
        .increment-control input {
            width: 80px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .increment-control label {
            font-weight: bold;
        }
        
        .visualization {
            display: none;
            width: 100%;
            height: 300px;
            background-color: #eee;
            position: relative;
            overflow: hidden;
            border-radius: 5px;
            margin: 20px 0;
            perspective: 800px;
        }
        
        .probe {
            position: absolute;
            width: 40px;
            height: 40px;
            background-color: #ff4757;
            border-radius: 50%;
            transform-style: preserve-3d;
            transition: all 0.3s ease;
            box-shadow: 0 0 10px rgba(0,0,0,0.2);
        }
        
        .probe:after {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            background-color: #333;
            transform: translateY(-50%);
        }
        
        .probe:before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            width: 2px;
            height: 100%;
            background-color: #333;
            transform: translateX(-50%);
        }
        
        .floor {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 1px;
            background-color: #999;
            transform: rotateX(60deg);
            transform-origin: bottom;
        }
        
        .grid {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(rgba(255,255,255,0) 0%, rgba(0,0,0,0.1) 100%);
            background-size: 40px 40px;
            background-image:
                linear-gradient(to right, #ddd 1px, transparent 1px),
                linear-gradient(to bottom, #ddd 1px, transparent 1px);
            transform: rotateX(60deg);
            transform-origin: bottom;
        }
        
        .axis {
            position: absolute;
            background-color: rgba(0,0,0,0.5);
        }
        
        .x-axis {
            bottom: 20px;
            left: 0;
            width: 100%;
            height: 2px;
        }
        
        .y-axis {
            bottom: 0;
            left: 50%;
            width: 2px;
            height: 100%;
        }
        
        .z-axis {
            bottom: 20px;
            left: 50%;
            width: 2px;
            height: 100px;
            transform: rotateX(-30deg);
            transform-origin: bottom;
        }
        
        .axis-label {
            position: absolute;
            font-weight: bold;
            font-size: 12px;
            color: #333;
        }
        
        .x-label {
            bottom: 5px;
            right: 10px;
        }
        
        .y-label {
            top: 10px;
            left: 52%;
        }
        
        .z-label {
            bottom: 100px;
            left: 52%;
        }
        
        .history {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            margin-top: 20px;
            height: 200px;
            overflow-y: auto;
        }
        
        .history h3 {
            margin-top: 0;
            font-size: 16px;
        }
        
        .history-item {
            padding: 5px 0;
            border-bottom: 1px solid #eee;
            font-family: monospace;
        }
        
        .success {
            color: #28a745;
        }
        
        .error {
            color: #dc3545;
        }
        
        .keyboard-shortcuts {
            display: none; /* Hidden keyboard shortcuts section */
            background-color: #e9ecef;
            padding: 10px;
            border-radius: 5px;
            margin-top: 20px;
        }
        
        .keyboard-shortcuts h3 {
            margin-top: 0;
            font-size: 16px;
        }
        
        .shortcuts-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-gap: 10px;
        }
        
        .shortcut {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        kbd {
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 3px;
            box-shadow: 0 1px 0 rgba(0,0,0,0.2);
            color: #333;
            display: inline-block;
            font-size: 12px;
            line-height: 1;
            padding: 5px;
            margin: 0 5px;
        }
        
        .api-controls {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        
        .api-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: #2196F3;
        }
        
        input:checked + .slider:before {
            transform: translateX(26px);
        }
        
        .status-indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 5px;
        }
        
        .status-online {
            background-color: #28a745;
        }
        
        .status-offline {
            background-color: #dc3545;
        }
        
        .status-text {
            font-weight: bold;
        }
        
        .find-objects-btn {
            padding: 8px 12px;
            background-color: #17a2b8;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .find-objects-btn:hover {
            background-color: #138496;
        }
        
        .object-selector {
            margin-top: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .object-selector select {
            flex: 1;
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ddd;
            display: none;
        }
        
        .object-selector label {
            display: none;
        }
        
        .sync-btn {
            padding: 8px 12px;
            background-color: #ffc107;
            color: #212529;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 10px;
        }
        
        .sync-btn:hover {
            background-color: #e0a800;
        }
        
        .toggle-positions-btn {
            padding: 8px 12px;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 10px;
        }
        
        .toggle-positions-btn:hover {
            background-color: #5a6268;
        }
    </style>
</head>
<body>
    <h1>3D Probe Controller</h1>

    <input type="text" name="my-textbox" id="my-textbox" placeholder="Enter anchor code here">
    
    <div class="api-info">
        Connect to API: <span id="api-endpoint">https://cwruxrgateway.azurewebsites.net/api/v4/Object</span>
    </div>
    
    <div class="container">
        <div class="api-controls">
            <div class="api-toggle">
                <span class="status-text">API Control: </span>
                <label class="toggle-switch">
                    <input type="checkbox" id="apiToggle" checked>
                    <span class="slider"></span>
                </label>
            </div>
            <button id="findObjects" class="find-objects-btn">Find the Objects</button>
            <div>
                <span class="status-indicator" id="apiStatus"></span>
                <span id="apiStatusText">Checking connection...</span>
            </div>
        </div>
        
        <div class="object-selector">
            <label for="objectSelect">Selected Object:</label>
            <select id="objectSelect">
                <option value="default">Default Target Object</option>
            </select>
            <button id="syncPosition" class="sync-btn">Sync Position</button>
            <button id="togglePositions" class="toggle-positions-btn">Show Positions</button>
        </div>
        
        <div class="visualization">
            <div class="grid"></div>
            <div class="floor"></div>
            <div class="probe" id="probe"></div>
            <div class="axis x-axis"></div>
            <div class="axis y-axis"></div>
            <div class="axis z-axis"></div>
            <div class="axis-label x-label">X</div>
            <div class="axis-label y-label">Y</div>
            <div class="axis-label z-label">Z</div>
        </div>
        
        <div class="position-display">
            <div class="position-card">
                <h3>X Position</h3>
                <div class="position-value" id="xPosition">0.000</div>
            </div>
            <div class="position-card">
                <h3>Y Position</h3>
                <div class="position-value" id="yPosition">0.000</div>
            </div>
            <div class="position-card">
                <h3>Z Position</h3>
                <div class="position-value" id="zPosition">0.000</div>
            </div>
            <div class="position-card">
                <h3>X Rotation</h3>
                <div class="position-value" id="xRotation">0.000</div>
            </div>
            <div class="position-card">
                <h3>Y Rotation</h3>
                <div class="position-value" id="yRotation">0.000</div>
            </div>
            <div class="position-card">
                <h3>Z Rotation</h3>
                <div class="position-value" id="zRotation">0.000</div>
            </div>
        </div>
        
        <div class="increment-control">
            <label for="increment">Movement Increment:</label>
            <input type="number" id="increment" value="0.01" step="0.001" min="0.001" max="1">
            <label for="rotationIncrement">Rotation Increment (deg):</label>
            <input type="number" id="rotationIncrement" value="15" step="1" min="1" max="90">
        </div>
        
        <h2>Movement Controls</h2>
        
        <div class="button-panel">
            <button id="up">UP (Y+)</button>
            <button id="left">LEFT (X-)</button>
            <button id="center">RESET</button>
            <button id="right">RIGHT (X+)</button>
            <button id="down">DOWN (Y-)</button>
        </div>
        
        <div class="z-buttons">
            <button id="forward">FORWARD (Z+)</button>
            <button id="backward">BACKWARD (Z-)</button>
        </div>
        
        <h2>Rotation Controls</h2>
        
        <div class="rotation-controls">
            <div class="rotation-panel">
                <button id="rotateXPlus">PITCH UP (X+)</button>
                <button id="rotateYPlus">YAW RIGHT (Y+)</button>
                <button id="rotateZPlus">ROLL CW (Z+)</button>
                <button id="rotateXMinus">PITCH DOWN (X-)</button>
                <button id="rotateYMinus">YAW LEFT (Y-)</button>
                <button id="rotateZMinus">ROLL CCW (Z-)</button>
                <button id="resetRotation" style="grid-column: span 3; background-color: #6c757d;">RESET ROTATION</button>
            </div>
        </div>
        
        <div class="keyboard-shortcuts">
            <h3>Keyboard Shortcuts</h3>
            <div class="shortcuts-grid">
                <div class="shortcut"><span>Move Up (Y+)</span> <kbd>↑</kbd></div>
                <div class="shortcut"><span>Move Down (Y-)</span> <kbd>↓</kbd></div>
                <div class="shortcut"><span>Move Left (X-)</span> <kbd>←</kbd></div>
                <div class="shortcut"><span>Move Right (X+)</span> <kbd>→</kbd></div>
                <div class="shortcut"><span>Move Forward (Z+)</span> <kbd>Page Up</kbd></div>
                <div class="shortcut"><span>Move Backward (Z-)</span> <kbd>Page Down</kbd></div>
                <div class="shortcut"><span>Reset Position</span> <kbd>Home</kbd></div>
                <div class="shortcut"><span>Pitch Up (X+)</span> <kbd>W</kbd></div>
                <div class="shortcut"><span>Pitch Down (X-)</span> <kbd>S</kbd></div>
                <div class="shortcut"><span>Yaw Left (Y-)</span> <kbd>A</kbd></div>
                <div class="shortcut"><span>Yaw Right (Y+)</span> <kbd>D</kbd></div>
                <div class="shortcut"><span>Roll CW (Z+)</span> <kbd>E</kbd></div>
                <div class="shortcut"><span>Roll CCW (Z-)</span> <kbd>Q</kbd></div>
                <div class="shortcut"><span>Reset Rotation</span> <kbd>R</kbd></div>
            </div>
        </div>
        
        <div class="history">
            <h3>Movement History</h3>
            <div id="historyContainer"></div>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // API configuration
            var API_CONFIG = {
                endpoint: 'https://cwruxrgateway.azurewebsites.net/api/v4/Object',
                headers: {
                    'Content-Type': 'application/json',
                    'ApiKey': '2B06144BF7FF64746EBFBB2C903F59'
                    // AnchorCode will be added from textbox input
                },
                targetObjectSource: 'https://cwruxrdeck.blob.core.windows.net/filecache/c4433760-1861-4882-9c06-0bda81682004.obj'
            };
            
            // Get DOM elements
            const probe = document.getElementById('probe');
            const xPosition = document.getElementById('xPosition');
            const yPosition = document.getElementById('yPosition');
            const zPosition = document.getElementById('zPosition');
            const xRotation = document.getElementById('xRotation');
            const yRotation = document.getElementById('yRotation');
            const zRotation = document.getElementById('zRotation');
            const incrementInput = document.getElementById('increment');
            const rotationIncrementInput = document.getElementById('rotationIncrement');
            const historyContainer = document.getElementById('historyContainer');
            const apiToggle = document.getElementById('apiToggle');
            const apiStatus = document.getElementById('apiStatus');
            const apiStatusText = document.getElementById('apiStatusText');
            const findObjectsBtn = document.getElementById('findObjects');
            const objectSelect = document.getElementById('objectSelect');
            const anchorCodeInput = document.getElementById('my-textbox');
            const syncPositionBtn = document.getElementById('syncPosition');
            const togglePositionsBtn = document.getElementById('togglePositions');
            const positionDisplay = document.querySelector('.position-display');
            
            // API state
            let apiConnected = false;
            let targetObject = null;
            let allObjects = [];
            let currentObjectId = null; // Track the current object ID for syncing
            
            // Current position and rotation
            let position = {
                x: 0,
                y: 0,
                z: 0
            };
            
            let eulerRotation = {
                x: 0, // pitch
                y: 0, // yaw
                z: 0  // roll
            };
            
            // Initial probe position and rotation
            updateProbe();
            
            // Movement directions
            const directions = {
                up: { axis: 'y', value: 1, name: 'UP' },
                down: { axis: 'y', value: -1, name: 'DOWN' },
                left: { axis: 'x', value: -1, name: 'LEFT' },
                right: { axis: 'x', value: 1, name: 'RIGHT' },
                forward: { axis: 'z', value: 1, name: 'FORWARD' },
                backward: { axis: 'z', value: -1, name: 'BACKWARD' }
            };
            
            // Rotation directions
            const rotations = {
                rotateXPlus: { axis: 'x', value: 1, name: 'PITCH UP' },
                rotateXMinus: { axis: 'x', value: -1, name: 'PITCH DOWN' },
                rotateYPlus: { axis: 'y', value: 1, name: 'YAW RIGHT' },
                rotateYMinus: { axis: 'y', value: -1, name: 'YAW LEFT' },
                rotateZPlus: { axis: 'z', value: 1, name: 'ROLL CW' },
                rotateZMinus: { axis: 'z', value: -1, name: 'ROLL CCW' }
            };
            
            // Function to get current anchor code from textbox
            function getCurrentAnchorCode() {
                return anchorCodeInput.value.trim();
            }
            
            // Function to get API headers with current anchor code
            function getApiHeaders() {
                const headers = {...API_CONFIG.headers};
                const anchorCode = getCurrentAnchorCode();
                
                if (anchorCode) {
                    headers['AnchorCode'] = anchorCode;
                }
                
                return headers;
            }
            
            // Add to history
            function addToHistory(message, type = '') {
                const now = new Date().toLocaleTimeString();
                const historyItem = document.createElement('div');
                historyItem.className = 'history-item';
                if (type) historyItem.classList.add(type);
                historyItem.textContent = `[${now}] ${message}`;
                historyContainer.prepend(historyItem);
                
                // Limit history items
                if (historyContainer.children.length > 50) {
                    historyContainer.removeChild(historyContainer.lastChild);
                }
                
                console.log(`[${now}] ${message}`);
            }
            
            // Update API status
            function updateApiStatus(connected, message) {
                apiConnected = connected;
                apiStatus.className = 'status-indicator ' + (connected ? 'status-online' : 'status-offline');
                apiStatusText.textContent = message;
            }
            
            // Update probe position and rotation in visualization
            function updateProbe() {
                // Update position values display (if visible)
                xPosition.textContent = position.x.toFixed(3);
                yPosition.textContent = position.y.toFixed(3);
                zPosition.textContent = position.z.toFixed(3);
                
                // Update rotation values display (if visible)
                xRotation.textContent = eulerRotation.x.toFixed(3);
                yRotation.textContent = eulerRotation.y.toFixed(3);
                zRotation.textContent = eulerRotation.z.toFixed(3);
                
                // Calculate visual position (mapping 3D space to the visualization)
                const visualX = 50 + position.x * 500; // Center is 50%, multiplier for visual effect
                const visualY = 50 - position.y * 500; // Inverted Y axis in browser
                const visualZ = 0 + position.z * 500;  // Z affects size/shadow for 3D effect
                
                // Scale based on z position for perspective effect
                const scale = 1 + position.z * 0.5;
                
                // Convert rotation degrees to radians
                const rotX = eulerRotation.x * Math.PI / 180;
                const rotY = eulerRotation.y * Math.PI / 180;
                const rotZ = eulerRotation.z * Math.PI / 180;
                
                // Apply transformations (position and rotation)
                probe.style.left = `${visualX}%`;
                probe.style.top = `${visualY}%`;
                probe.style.transform = `translate(-50%, -50%) scale(${scale}) rotateX(${rotX}rad) rotateY(${rotY}rad) rotateZ(${rotZ}rad)`;
                
                // Z-index based on Y position to handle overlapping
                probe.style.zIndex = Math.floor(position.y * 100 + 100);
                
                // Adjust shadow based on height
                const shadowBlur = 5 + Math.abs(position.z) * 10;
                const shadowY = 5 + position.z * 15;
                probe.style.boxShadow = `0 ${shadowY}px ${shadowBlur}px rgba(0,0,0,0.2)`;
            }
            
            // Check API connection
            async function checkApiConnection() {
                if (!apiToggle.checked) {
                    updateApiStatus(false, 'API control disabled');
                    return false;
                }
                
                const anchorCode = getCurrentAnchorCode();
                if (!anchorCode) {
                    updateApiStatus(false, 'No anchor code provided');
                    addToHistory('Please enter an anchor code', 'error');
                    return false;
                }
                
                addToHistory(`Checking API connection with anchor code: ${anchorCode}...`);
                
                try {
                    const response = await fetch(API_CONFIG.endpoint, {
                        method: 'GET',
                        headers: getApiHeaders()
                    });
                    
                    addToHistory(`API response status: ${response.status}`);
                    
                    if (response.ok) {
                        updateApiStatus(true, 'Connected to API');
                        addToHistory('API connection successful', 'success');
                        return true;
                    } else {
                        updateApiStatus(false, `API error: ${response.status}`);
                        addToHistory(`API connection failed: ${response.status}`, 'error');
                        return false;
                    }
                } catch (error) {
                    updateApiStatus(false, `Connection error: ${error.message}`);
                    addToHistory(`Connection error: ${error.message}`, 'error');
                    return false;
                }
            }
            
            // Sync position from API
            async function syncPositionFromAPI() {
                if (!apiToggle.checked || !apiConnected) {
                    addToHistory('Cannot sync - API not connected', 'error');
                    return false;
                }
                
                const selectedObjectId = objectSelect.value;
                if (selectedObjectId === 'default') {
                    addToHistory('Cannot sync - no object selected', 'error');
                    return false;
                }
                
                try {
                    addToHistory(`Syncing position and rotation from API for object: ${selectedObjectId}`);
                    
                    const response = await fetch(`${API_CONFIG.endpoint}/${selectedObjectId}`, {
                        method: 'GET',
                        headers: getApiHeaders()
                    });
                    
                    if (!response.ok) {
                        throw new Error(`API error: ${response.status}`);
                    }
                    
                    const objectData = await response.json();
                    
                    // Update local position and rotation from API data
                    if (objectData.pose) {
                        if (objectData.pose.position) {
                            position = {
                                x: objectData.pose.position.x || 0,
                                y: objectData.pose.position.y || 0,
                                z: objectData.pose.position.z || 0
                            };
                        }
                        
                        if (objectData.pose.eulerRotation) {
                            eulerRotation = {
                                x: parseFloat(objectData.pose.eulerRotation.x) || 0,
                                y: parseFloat(objectData.pose.eulerRotation.y) || 0,
                                z: parseFloat(objectData.pose.eulerRotation.z) || 0
                            };
                        }
                    }
                    
                    updateProbe();
                    addToHistory(`Position and rotation synced - Pos: X=${position.x.toFixed(3)}, Y=${position.y.toFixed(3)}, Z=${position.z.toFixed(3)} Rot: X=${eulerRotation.x.toFixed(3)}, Y=${eulerRotation.y.toFixed(3)}, Z=${eulerRotation.z.toFixed(3)}`, 'success');
                    return true;
                    
                } catch (error) {
                    addToHistory(`Error syncing position: ${error.message}`, 'error');
                    return false;
                }
            }
            
            // Find objects in API
            async function findObjects() {
                if (!apiToggle.checked) {
                    addToHistory('API control is disabled', 'error');
                    return;
                }
                
                const anchorCode = getCurrentAnchorCode();
                if (!anchorCode) {
                    addToHistory('Please enter an anchor code', 'error');
                    return;
                }
                
                addToHistory(`Searching for objects with anchor code: ${anchorCode}...`);
                
                try {
                    const response = await fetch(API_CONFIG.endpoint, {
                        method: 'GET',
                        headers: getApiHeaders()
                    });
                    
                    addToHistory(`Find objects response status: ${response.status}`);
                    
                    if (!response.ok) {
                        throw new Error(`API error: ${response.status}`);
                    }
                    
                    const responseText = await response.text();
                    addToHistory(`API response length: ${responseText.length} characters`);
                    
                    // Try to parse JSON
                    let parsedObjects;
                    try {
                        parsedObjects = JSON.parse(responseText);
                    } catch (parseError) {
                        addToHistory(`JSON parse error: ${parseError.message}`, 'error');
                        addToHistory(`Response preview: ${responseText.substring(0, 200)}...`, 'error');
                        return;
                    }
                    
                    // Handle different response formats
                    if (Array.isArray(parsedObjects)) {
                        allObjects = parsedObjects;
                    } else if (parsedObjects && typeof parsedObjects === 'object') {
                        // If response is an object, check for common array properties
                        if (parsedObjects.objects && Array.isArray(parsedObjects.objects)) {
                            allObjects = parsedObjects.objects;
                        } else if (parsedObjects.items && Array.isArray(parsedObjects.items)) {
                            allObjects = parsedObjects.items;
                        } else if (parsedObjects.data && Array.isArray(parsedObjects.data)) {
                            allObjects = parsedObjects.data;
                        } else {
                            // Single object response
                            allObjects = [parsedObjects];
                        }
                    } else {
                        addToHistory('Unexpected API response format', 'error');
                        return;
                    }
                    
                    addToHistory(`Found ${allObjects.length} objects total`);
                    
                    // Log object details for debugging
                    allObjects.forEach((obj, index) => {
                        addToHistory(`Object ${index}: ID=${obj.id || 'N/A'}, Type=${obj.type || 'N/A'}, Source=${obj.source ? obj.source.substring(0, 50) + '...' : 'N/A'}`);
                    });
                    
                    // Clear select options
                    objectSelect.innerHTML = '';
                    
                    // Add default option
                    const defaultOption = document.createElement('option');
                    defaultOption.value = 'default';
                    defaultOption.textContent = 'Default Target Object';
                    objectSelect.appendChild(defaultOption);
                    
                    if (allObjects.length === 0) {
                        addToHistory('No objects returned from API', 'error');
                        currentObjectId = null;
                        updateApiStatus(true, 'Connected - No objects found');
                        return;
                    }
                    
                    // Find target object by source
                    const targetObjects = allObjects.filter(obj => 
                        obj.source === API_CONFIG.targetObjectSource
                    );
                    
                    if (targetObjects.length > 0) {
                        // Found the specific target object
                        targetObject = targetObjects[0];
                        currentObjectId = targetObject.id;
                        addToHistory(`Found target object: ${targetObject.id}`, 'success');
                    } else if (allObjects.length > 0) {
                        // No specific target found, use the first available object
                        targetObject = allObjects[0];
                        currentObjectId = targetObject.id;
                        addToHistory(`Target object not found, using first available: ${targetObject.id}`, 'success');
                    } else {
                        addToHistory('No objects found', 'error');
                        currentObjectId = null;
                        updateApiStatus(true, `Found 0 objects`);
                        return;
                    }
                    
                    addToHistory(`Selected object ID: ${currentObjectId}`);
                    
                    // Update position and rotation from selected object
                    if (targetObject.pose) {
                        addToHistory('Object has pose data');
                        if (targetObject.pose.position) {
                            position = {
                                x: targetObject.pose.position.x || 0,
                                y: targetObject.pose.position.y || 0,
                                z: targetObject.pose.position.z || 0
                            };
                            addToHistory(`Initial position: X=${position.x}, Y=${position.y}, Z=${position.z}`);
                        }
                        if (targetObject.pose.eulerRotation) {
                            eulerRotation = {
                                x: parseFloat(targetObject.pose.eulerRotation.x) || 0,
                                y: parseFloat(targetObject.pose.eulerRotation.y) || 0,
                                z: parseFloat(targetObject.pose.eulerRotation.z) || 0
                            };
                            addToHistory(`Initial rotation: X=${eulerRotation.x}, Y=${eulerRotation.y}, Z=${eulerRotation.z}`);
                        }
                        updateProbe();
                    } else {
                        // Initialize with default position if no pose data
                        addToHistory('Object has no pose data, using defaults');
                        position = { x: 0, y: 0, z: 0 };
                        eulerRotation = { x: 0, y: 0, z: 0 };
                        updateProbe();
                    }
                    
                    // Add target object to select (for backward compatibility)
                    const targetOption = document.createElement('option');
                    targetOption.value = targetObject.id;
                    targetOption.textContent = `Target: ${targetObject.id} (${targetObject.type || 'Unknown'})`;
                    targetOption.selected = true;
                    objectSelect.appendChild(targetOption);
                    
                    // Add other objects to select
                    allObjects.forEach(obj => {
                        if (!targetObject || obj.id !== targetObject.id) {
                            const option = document.createElement('option');
                            option.value = obj.id;
                            option.textContent = `${obj.id} (${obj.type || 'Unknown'})`;
                            objectSelect.appendChild(option);
                        }
                    });
                    
                    updateApiStatus(true, `Found ${allObjects.length} objects - Using: ${currentObjectId}`);
                    addToHistory('Object selection complete', 'success');
                    
                } catch (error) {
                    addToHistory(`Error finding objects: ${error.message}`, 'error');
                    updateApiStatus(false, 'Connection error');
                    currentObjectId = null;
                }
            }
            
            // Move in a direction
            async function move(direction) {
                const dir = directions[direction];
                if (!dir) return;
                
                // Sync position from API before moving if API is connected and we have an object
                if (apiToggle.checked && apiConnected && currentObjectId) {
                    const syncSuccess = await syncPositionFromAPI();
                    if (!syncSuccess) {
                        addToHistory('Warning: Could not sync position before movement', 'error');
                    }
                }
                
                const increment = parseFloat(incrementInput.value) || 0.01;
                
                // Update ONLY the position, don't change rotation
                const oldPosition = {...position};
                position[dir.axis] += dir.value * increment;
                
                // Update visualization
                updateProbe();
                
                // Add to history
                addToHistory(`Move ${dir.name}: ${dir.axis.toUpperCase()} ${oldPosition[dir.axis].toFixed(3)} → ${position[dir.axis].toFixed(3)}`);
                
                // Update API if connected
                await updateObjectInAPI();
            }
            
            // Rotate in a direction
            async function rotate(direction) {
                const rot = rotations[direction];
                if (!rot) return;
                
                // Sync position from API before rotating if API is connected and we have an object
                if (apiToggle.checked && apiConnected && currentObjectId) {
                    const syncSuccess = await syncPositionFromAPI();
                    if (!syncSuccess) {
                        addToHistory('Warning: Could not sync position before rotation', 'error');
                    }
                }
                
                const increment = parseFloat(rotationIncrementInput.value) || 15;
                
                // Update local rotation
                eulerRotation[rot.axis] += rot.value * increment;
                
                // Normalize rotation to 0-360
                eulerRotation[rot.axis] = (eulerRotation[rot.axis] + 360) % 360;
                
                // Update visualization
                updateProbe();
                
                // Add to history
                addToHistory(`Rotate ${rot.name}: ${rot.axis.toUpperCase()} ${rot.value > 0 ? '+' : ''}${rot.value * increment}`);
                
                // Update API if connected
                await updateObjectInAPI();
            }
            
            // Reset position
            async function resetPosition() {
                position = { x: 0, y: 0, z: 0 };
                updateProbe();
                addToHistory('Position reset to origin');
                
                // Update API if connected
                await updateObjectInAPI();
            }
            
            // Reset rotation
            async function resetRotation() {
                eulerRotation = { x: 0, y: 0, z: 0 };
                updateProbe();
                addToHistory('Rotation reset to zero');
                
                // Update API if connected
                await updateObjectInAPI();
            }
            
            // Update object in API
            async function updateObjectInAPI() {
                if (!apiToggle.checked || !apiConnected) {
                    return;
                }
                
                // Use currentObjectId if available, otherwise fall back to select value
                const selectedObjectId = currentObjectId || objectSelect.value;
                if (!selectedObjectId || selectedObjectId === 'default') {
                    return;
                }
                
                try {
                    // Find selected object
                    const selectedObject = allObjects.find(obj => obj.id === selectedObjectId);
                    if (!selectedObject) {
                        addToHistory('Selected object not found', 'error');
                        return;
                    }
                    
                    // Update pose
                    selectedObject.pose = {
                        position: { ...position },
                        eulerRotation: { ...eulerRotation }
                    };
                    
                    // Send update to API
                    const response = await fetch(`${API_CONFIG.endpoint}/${selectedObjectId}`, {
                        method: 'PUT',
                        headers: getApiHeaders(),
                        body: JSON.stringify(selectedObject)
                    });
                    
                    if (response.ok) {
                        addToHistory(`Updated object ${selectedObjectId} in API`, 'success');
                    } else {
                        addToHistory(`API update error: ${response.status}`, 'error');
                    }
                } catch (error) {
                    addToHistory(`Error updating API: ${error.message}`, 'error');
                }
            }
            
            // Toggle position display visibility
            function togglePositionDisplay() {
                const isVisible = positionDisplay.style.display === 'flex';
                
                if (isVisible) {
                    positionDisplay.style.display = 'none';
                    togglePositionsBtn.textContent = 'Show Positions';
                    addToHistory('Position displays hidden');
                } else {
                    positionDisplay.style.display = 'flex';
                    togglePositionsBtn.textContent = 'Hide Positions';
                    addToHistory('Position displays shown');
                }
            }
            
            // Change selected object
            function changeSelectedObject() {
                const selectedObjectId = objectSelect.value;
                
                if (selectedObjectId === 'default') {
                    // Reset to default
                    position = { x: 0, y: 0, z: 0 };
                    eulerRotation = { x: 0, y: 0, z: 0 };
                    updateProbe();
                    addToHistory('Switched to default object');
                    return;
                }
                
                // Find selected object
                const selectedObject = allObjects.find(obj => obj.id === selectedObjectId);
                if (!selectedObject) {
                    addToHistory('Selected object not found', 'error');
                    return;
                }
                
                // Update position and rotation from selected object
                if (selectedObject.pose) {
                    if (selectedObject.pose.position) {
                        position = {
                            x: selectedObject.pose.position.x || 0,
                            y: selectedObject.pose.position.y || 0,
                            z: selectedObject.pose.position.z || 0
                        };
                    } else {
                        position = { x: 0, y: 0, z: 0 };
                    }
                    
                    if (selectedObject.pose.rotation) {  // Note: this should be eulerRotation, not rotation
                        eulerRotation = {
                            x: parseFloat(selectedObject.pose.eulerRotation.x) || 0,
                            y: parseFloat(selectedObject.pose.eulerRotation.y) || 0,
                            z: parseFloat(selectedObject.pose.eulerRotation.z) || 0
                        };
                    } else {
                        eulerRotation = { x: 0, y: 0, z: 0 };
                    }
                } else {
                    position = { x: 0, y: 0, z: 0 };
                    eulerRotation = { x: 0, y: 0, z: 0 };
                }
                
                updateProbe();
                addToHistory(`Switched to object: ${selectedObjectId}`);
            }
            
            // Initialize events
            function initEvents() {
                // Movement buttons
                document.getElementById('up').addEventListener('click', () => move('up'));
                document.getElementById('down').addEventListener('click', () => move('down'));
                document.getElementById('left').addEventListener('click', () => move('left'));
                document.getElementById('right').addEventListener('click', () => move('right'));
                document.getElementById('forward').addEventListener('click', () => move('forward'));
                document.getElementById('backward').addEventListener('click', () => move('backward'));
                document.getElementById('center').addEventListener('click', resetPosition);
                
                // Rotation buttons
                document.getElementById('rotateXPlus').addEventListener('click', () => rotate('rotateXPlus'));
                document.getElementById('rotateXMinus').addEventListener('click', () => rotate('rotateXMinus'));
                document.getElementById('rotateYPlus').addEventListener('click', () => rotate('rotateYPlus'));
                document.getElementById('rotateYMinus').addEventListener('click', () => rotate('rotateYMinus'));
                document.getElementById('rotateZPlus').addEventListener('click', () => rotate('rotateZPlus'));
                document.getElementById('rotateZMinus').addEventListener('click', () => rotate('rotateZMinus'));
                document.getElementById('resetRotation').addEventListener('click', resetRotation);
                
                // API controls
                findObjectsBtn.addEventListener('click', findObjects);
                apiToggle.addEventListener('change', checkApiConnection);
                objectSelect.addEventListener('change', changeSelectedObject);
                syncPositionBtn.addEventListener('click', syncPositionFromAPI);
                togglePositionsBtn.addEventListener('click', togglePositionDisplay);
                
                // Keyboard controls
                document.addEventListener('keydown', function(event) {
                    // Movement keys
                    switch(event.key) {
                        case 'ArrowUp':
                            move('up');
                            event.preventDefault();
                            break;
                        case 'ArrowDown':
                            move('down');
                            event.preventDefault();
                            break;
                        case 'ArrowLeft':
                            move('left');
                            event.preventDefault();
                            break;
                        case 'ArrowRight':
                            move('right');
                            event.preventDefault();
                            break;
                        case 'PageUp':
                            move('forward');
                            event.preventDefault();
                            break;
                        case 'PageDown':
                            move('backward');
                            event.preventDefault();
                            break;
                        case 'Home':
                            resetPosition();
                            event.preventDefault();
                            break;
                        // Rotation keys
                        case 'w':
                        case 'W':
                            rotate('rotateXPlus');
                            break;
                        case 's':
                        case 'S':
                            rotate('rotateXMinus');
                            break;
                        case 'a':
                        case 'A':
                            rotate('rotateYMinus');
                            break;
                        case 'd':
                        case 'D':
                            rotate('rotateYPlus');
                            break;
                        case 'q':
                        case 'Q':
                            rotate('rotateZMinus');
                            break;
                        case 'e':
                        case 'E':
                            rotate('rotateZPlus');
                            break;
                        case 'r':
                        case 'R':
                            resetRotation();
                            break;
                    }
                });
                
                // Anchor code input change
                anchorCodeInput.addEventListener('change', checkApiConnection);
            }
            
            // Initialize the controller
            function init() {
                addToHistory('3D Probe Controller initialized');
                initEvents();
                
                // Check connection first
                checkApiConnection().then(connected => {
                    if (connected) {
                        addToHistory('API connection established, searching for objects...');
                        findObjects();
                    } else {
                        addToHistory('API connection failed - check anchor code and try again', 'error');
                    }
                });
            }
            
            // Start the controller
            init();
        });
    </script>
</body>
</html> 
